// Code generated by MockGen. DO NOT EDIT.
// Source: internal/core/port/usecase.go

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"

	domain "github.com/br4tech/auth-nex/internal/core/domain"
	dto "github.com/br4tech/auth-nex/internal/dto"
	model "github.com/br4tech/auth-nex/internal/model"
	gomock "go.uber.org/mock/gomock"
)

// MockIUserUseCase is a mock of IUserUseCase interface.
type MockIUserUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIUserUseCaseMockRecorder
}

// MockIUserUseCaseMockRecorder is the mock recorder for MockIUserUseCase.
type MockIUserUseCaseMockRecorder struct {
	mock *MockIUserUseCase
}

// NewMockIUserUseCase creates a new mock instance.
func NewMockIUserUseCase(ctrl *gomock.Controller) *MockIUserUseCase {
	mock := &MockIUserUseCase{ctrl: ctrl}
	mock.recorder = &MockIUserUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUserUseCase) EXPECT() *MockIUserUseCaseMockRecorder {
	return m.recorder
}

// Authenticate mocks base method.
func (m *MockIUserUseCase) Authenticate(userReq *dto.UserTokenDTO) (*string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Authenticate", userReq)
	ret0, _ := ret[0].(*string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Authenticate indicates an expected call of Authenticate.
func (mr *MockIUserUseCaseMockRecorder) Authenticate(userReq interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Authenticate", reflect.TypeOf((*MockIUserUseCase)(nil).Authenticate), userReq)
}

// CreateUser mocks base method.
func (m *MockIUserUseCase) CreateUser(user *domain.User) (*domain.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", user)
	ret0, _ := ret[0].(*domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockIUserUseCaseMockRecorder) CreateUser(user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIUserUseCase)(nil).CreateUser), user)
}

// ValidateAccessToken mocks base method.
func (m *MockIUserUseCase) ValidateAccessToken(tokenString string) (*model.Claims, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateAccessToken", tokenString)
	ret0, _ := ret[0].(*model.Claims)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateAccessToken indicates an expected call of ValidateAccessToken.
func (mr *MockIUserUseCaseMockRecorder) ValidateAccessToken(tokenString interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateAccessToken", reflect.TypeOf((*MockIUserUseCase)(nil).ValidateAccessToken), tokenString)
}

// MockIPermissionUseCase is a mock of IPermissionUseCase interface.
type MockIPermissionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockIPermissionUseCaseMockRecorder
}

// MockIPermissionUseCaseMockRecorder is the mock recorder for MockIPermissionUseCase.
type MockIPermissionUseCaseMockRecorder struct {
	mock *MockIPermissionUseCase
}

// NewMockIPermissionUseCase creates a new mock instance.
func NewMockIPermissionUseCase(ctrl *gomock.Controller) *MockIPermissionUseCase {
	mock := &MockIPermissionUseCase{ctrl: ctrl}
	mock.recorder = &MockIPermissionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIPermissionUseCase) EXPECT() *MockIPermissionUseCaseMockRecorder {
	return m.recorder
}

// CreateRole mocks base method.
func (m *MockIPermissionUseCase) CreateRole(name string) (*domain.Role, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRole", name)
	ret0, _ := ret[0].(*domain.Role)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRole indicates an expected call of CreateRole.
func (mr *MockIPermissionUseCaseMockRecorder) CreateRole(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRole", reflect.TypeOf((*MockIPermissionUseCase)(nil).CreateRole), name)
}

// FindRoleByName mocks base method.
func (m *MockIPermissionUseCase) FindRoleByName(name string) (*domain.Role, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindRoleByName", name)
	ret0, _ := ret[0].(*domain.Role)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindRoleByName indicates an expected call of FindRoleByName.
func (mr *MockIPermissionUseCaseMockRecorder) FindRoleByName(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindRoleByName", reflect.TypeOf((*MockIPermissionUseCase)(nil).FindRoleByName), name)
}

// MockICompanyUseCase is a mock of ICompanyUseCase interface.
type MockICompanyUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockICompanyUseCaseMockRecorder
}

// MockICompanyUseCaseMockRecorder is the mock recorder for MockICompanyUseCase.
type MockICompanyUseCaseMockRecorder struct {
	mock *MockICompanyUseCase
}

// NewMockICompanyUseCase creates a new mock instance.
func NewMockICompanyUseCase(ctrl *gomock.Controller) *MockICompanyUseCase {
	mock := &MockICompanyUseCase{ctrl: ctrl}
	mock.recorder = &MockICompanyUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockICompanyUseCase) EXPECT() *MockICompanyUseCaseMockRecorder {
	return m.recorder
}

// CreateCompany mocks base method.
func (m *MockICompanyUseCase) CreateCompany(company *domain.Company) (*domain.Company, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateCompany", company)
	ret0, _ := ret[0].(*domain.Company)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateCompany indicates an expected call of CreateCompany.
func (mr *MockICompanyUseCaseMockRecorder) CreateCompany(company interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCompany", reflect.TypeOf((*MockICompanyUseCase)(nil).CreateCompany), company)
}

// FindCompanyById mocks base method.
func (m *MockICompanyUseCase) FindCompanyById(id int) (*domain.Company, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindCompanyById", id)
	ret0, _ := ret[0].(*domain.Company)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindCompanyById indicates an expected call of FindCompanyById.
func (mr *MockICompanyUseCaseMockRecorder) FindCompanyById(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindCompanyById", reflect.TypeOf((*MockICompanyUseCase)(nil).FindCompanyById), id)
}

// MockITenantUseCase is a mock of ITenantUseCase interface.
type MockITenantUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockITenantUseCaseMockRecorder
}

// MockITenantUseCaseMockRecorder is the mock recorder for MockITenantUseCase.
type MockITenantUseCaseMockRecorder struct {
	mock *MockITenantUseCase
}

// NewMockITenantUseCase creates a new mock instance.
func NewMockITenantUseCase(ctrl *gomock.Controller) *MockITenantUseCase {
	mock := &MockITenantUseCase{ctrl: ctrl}
	mock.recorder = &MockITenantUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITenantUseCase) EXPECT() *MockITenantUseCaseMockRecorder {
	return m.recorder
}

// CreateTenantWithCompanyAndAdmin mocks base method.
func (m *MockITenantUseCase) CreateTenantWithCompanyAndAdmin(tenant *dto.TenantDTO) (*domain.Tenant, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTenantWithCompanyAndAdmin", tenant)
	ret0, _ := ret[0].(*domain.Tenant)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateTenantWithCompanyAndAdmin indicates an expected call of CreateTenantWithCompanyAndAdmin.
func (mr *MockITenantUseCaseMockRecorder) CreateTenantWithCompanyAndAdmin(tenant interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTenantWithCompanyAndAdmin", reflect.TypeOf((*MockITenantUseCase)(nil).CreateTenantWithCompanyAndAdmin), tenant)
}
